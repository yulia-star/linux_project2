## Part 1. Инструмент ipcalc

ipclac 192.167.38.54/13 # узнать IP-адрес, маску подсети, broadcast и др. в десятиричной и двоичной системах

### 1.1. Сети и маски
Определить и записать в отчёт:
1) Адрес сети 192.167.38.54/13:
     Address: 192.167.38.54        11000000.10100 111.00100110.00110110
2) Перевод маски:
     255.255.255.0 в префиксную и двоичную запись - /24
     /15 в обычную и двоичную - 255.254.0.0
     11111111.11111111.11111111.11110000 в обычную и префиксную - /28
3) Минимальный и максимальный хост в сети 12.167.38.4 при масках:
     /8 - 192.0.0.1 - 192.255.255.254 (первый (192.0.0.0) и последний (192.255.255.255 - для broadcast) номера резервируются)
     11111111.11111111.00000000.00000000 - 192.167.0.1 - 192.167.255.254
     255.255.254.0 - 192.167.38.1 - 192.167.39.254
     /4 - 192.0.0.1 - 207.255.255.254

### 1.2. localhost
диапазон 127.0.0.1 - 127.255.255.254 используется только для локальных сетей
Определить и записать в отчёт, можно ли обратиться к приложению, работающему на localhost, со следующими IP:
```
  194.34.23.100 - нет
  127.0.0.2 - да
  127.1.0.1 - да
  128.0.0.1 - нет
```
### 1.3. Диапазоны и сегменты сетей
Публичные (белые) IP адреса - те, которые действуют в сети интернет
Приватные (серые) IP адреса - те, которые действуют в локальной сети (роутер раздает на устройства свои IP адреса,
которые не обращаются напрямую в интернет, а IP адрес роутера будет публичным)
```
Диапазоны приватных (частных, серых) подсетей:
10.0.0.0 — 10.255.255.255 (маска подсети для бесклассовой (CIDR) адресации: 255.0.0.0 или /8)
172.16.0.0 — 172.31.255.255 (маска подсети для бесклассовой (CIDR) адресации: 255.240.0.0 или /12)
192.168.0.0 — 192.168.255.255 (маска подсети для бесклассовой (CIDR) адресации: 255.255.0.0 или /16)
```
Определить и записать в отчёт:
1) какие из перечисленных IP можно использовать в качестве публичного, а какие только в качестве частных:
  10.0.0.45 - част
  134.43.0.2 - публ
  192.168.4.2 - част
  172.20.250.4 - част
  172.0.2.1 - публ
  192.172.0.1 - публ
  172.68.0.2 - публ
  172.16.255.255 - част
  10.10.10.10 - част
  192.169.168.1 - публ
2) какие из перечисленных IP адресов шлюза возможны у сети 10.10.0.0/18:
  10.0.0.1 - да
  10.10.0.2 - да
  10.10.10.10 - да
  10.10.100.1 - нет
  10.10.1.255 - нет
  
  Для данной сети 10.10.0.0/18:
    HostMin: 10.10.0.1
    HostMax: 10.10.63.254
  Ответы, исходя их этого диапазона
  
## Part 2. Статическая маршрутизация между двумя машинами
ip a # просмотр ip адреса (то же самое, что ip addr)

Описать сетевой интерфейс, соответствующий внутренней сети, на обеих машинах и задать следующие адреса и маски:
  ws1 - 192.168.100.10, маска /16
  ws2 - 172.24.116.8, маска /12
Изменяемый файл: etc/netplan/00-installer-config.yaml

### 2.1. Добавление статического маршрута вручную
Добавить статический маршрут от одной машины до другой и обратно при помощи команды вида ip r add
Пропинговать соединение между машинами
В отчёт поместить скрин с вызовом и выводом использованных команд.

Мое выполнение:
  в VirtualBox на обеих ws зашла в настройки > Сеть > Адаптер 2 > Включить сетевой адаптер > Тип подключения: Внутренняя сеть
  это привело к тому, что на обеих ws появился интерфейс enp0s8
  
Далее вводим команду sudo route add:
```
ws1:
  sudo ip r add 172.24.116.8 via 192.168.100.10
  после этого при попытке пинга 172.24.116.8 соединения еще не будет
  ping 172.24.116.8
ws2:
  sudo ip r add 192.168.100.10 via 172.24.116.8
  после этого можно проверить пинг на обеих машинах, будет соединяться
  ping 192.168.100.10
```
Данная настройка будет сброшена при перезагрузке виртуальных машин

Теория:
Синтаксис добавления нового маршрута в таблицу маршрутизации такой:
  - ip route add подсеть/маска via шлюз
Вместо шлюза можно указать сетевой интерфейс с помощью которого надо отправлять пакеты:
  - ip route add подсеть/маска dev устройство
Например, добавим новый маршрут для сети через тот же IP адрес:
  sudo ip route add 169.255.0.0 via 169.254.19.153
Или можно указать сетевой интерфейс через который надо отправлять пакеты для определённой сети:
  sudo ip route add 169.255.0.0 dev enp0s3

### 2.2. Добавление статического маршрута с сохранением
Перезапустить машины
Добавить статический маршрут от одной машины до другой с помощью файла etc/netplan/00-installer-config.yaml
В отчёт поместить скрин с содержанием изменённого файла etc/netplan/00-installer-config.yaml.
Пропинговать соединение между машинами

На обеих ws внесла изменения в файл etc/netplan/00-installer-config.yaml (разница только в ip):
```
ws1:
# This is the network config written by 'sibiquity'
network:
  ethernets:
    enp0s8:
      dhcp4: false
      addresses: [192.168.100.10/16]
      nameservers:
        addresses: [8.8.8.8, 1.1.1.1]
      routes:
          - to: 172.24.116.8
            via: 192.168.100.10
    enp0s3:
      dhcp4: true
   version: 2
```
```
ws2:
# This is the network config written by 'sibiquity'
network:
  ethernets:
    enp0s8:
      dhcp4: false
      addresses: [172.24.116.8/12]
      nameservers:
        addresses: [8.8.8.8, 1.1.1.1]
      routes:
          - to: 192.168.100.10
            via: 172.24.116.8
    enp0s3:
      dhcp4: true
   version: 2
```
Далее для каждой машины выполнена команда для того, чтобы ip интерфейса применился:
  sudo netplan apply

Проверяем изменения одной из команд:
  ip a, ip addr, ifconfig
  
Далее вводим пингуем обе машины:
ws1:
  ping 172.24.116.8
ws2:
  ping 192.168.100.10

После перезагрузки виртуальных соединение сохраняется, то есть можно сразу проверить ping

## Part 3. Утилита iperf3
### 3.1. Скорость соединения
Перевести и записать в отчёт:
  8 Mbps в MB/s = 1MB/s (Mbps (мегабит в секунду), MB/s (мегабайт в секунду). Основание перевода величин: 1 Mbps = 0.125 MB/s)
  100 MB/s в Kbps = 8 Mbps * 100 * 1000 = 800 000 Kbps (1 Mbps = 1000 kbps (килобит в секунду))
  1 Gbps в Mbps = 125 * 8 = 1000 Mbps (1 Gbps = 125 MB/s)

### 3.2. Утилита iperf3
Измерить скорость соединения между ws1 и ws2

Одну из машин запускаем как сервер, после этого запускаем на второй машине iperf3 -c - как клиента.
Пока одна из машин работает сервером, пингуется скорость.

__ws1 определили как сервер командой:__
  iperf3 -s
  
__ws2 определили клиентом командой, иметь ввиду, что указан ip сервера:__
  iperf3 -c 192.168.100.10
  
После этого на обеих машинах пошли соединения.
Bitrate в среднем:
  ws1: 748 Mbits/sec
  ws2: 718 Mbits/sec
  
## Part 4. Сетевой экран
### 4.1. Утилита iptables

iptable - это firewall, то есть межсетевой экран.
Firewall состоит цепочек, а они в свою очередь из таблиц.
```
Цепочки:

* Prerouting
* Input
* Output
* Postrouting
* Forward
```
__Есть 2 пути, по котору идут пакеты:__
1. Prerouting > Input > Преобразование в приложении > Output > Postroting
2. Prerouting > Forward > Postrouting

В каждой цепочке есть свои таблицы:
* nat - таблица для преобразования сетевых адресов
* filter (таблица по умолчанию, в нее записываются все правила, если таблица не указана явно) - в таблице прописываются правила DROP, REJECT, ACCEPT для определенных IP-адресов, портов и т.д.
* raw (задается маркировка пакета, для которого не требуются дальнейшие изменения)
* mangle (в таблице задается TTL - time to life, то есть время жизни пакета, если он не находит ответа)
* Connection (stale) Tracking (определение состояний conntrack) - определяет состояние пакета (new, esteblished, invalid или relaited) и на основании этого состояния делаются какие-то действия

![iptables](https://forum.nag.ru/uploads/monthly_2020_04/cbfruui7ydb8lqm19myzozfotbo.png.29639c65a69273e1361e6d985687a210.png)




iptables -L -nv
по умолчанию выведет правила в таблице __filter__.
В этой таблице правила для цепочек input, forward и output.
Нам очень важно отфильтровать пакеты на входе, чтобы злоумышленники не смогли отправить, например, зараженные пакеты, подключиться с открытых портов и т.д.


### Первоначальный набор правил для сервера в таблице filter в цепочке input:

1. разрешение трафика по ssh:
```
sudo iptables -A INPUT -p tcp --dport=22 -j ACCEPT # __-A__ _append (в конец списка)_, INPUT - _цепочка_, -p - _протокол_, --dport= - _порт_, -j - _действие_
```
2. разрешение трафика на lo (loop back / localhost). Здесь можно также настраивать трафик с других интерфейсов (enp0s3, eth0 и тд), главное, смотреть наименование своих интерфейсов:
```
sudo iptables -A INPUT -i lo -j ACCEPT # -i - _интерфейс_
```
3. разрешение протокола icmp - протокол, отвечающий за пинг
```
sudo iptables -A INPUT -p tcmp -j ACCEPT
```
4. разрешение портов для обслуживания web-сервера (порты 80 и 443):
```
sudo iptables -A INPUT -p tcp --dport=80 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport=443 -j ACCEPT
```
5. разрешение трафика входящих пакетов от установленных нами соединений, то есть ответы на наши запросы:
```
sudo iptables -A INPUT -m state --state ESTABLISHED, RELATED -j ACCEPT # -m - _модуль_
```

6. изменить политику по умолчанию (обязательно убедиться, что служба ssh настроена в iptable, иначе на этом моменты выкинет из соединения):
```
sudo iptables -P DROP # кроме DROP есть действие REJECT, которое отправляет ответ на каждый пакет (может расходовать ресурсы и обнаруживать себя в сети), DROP же просто удаляет ненужные пакеты
```

7. запретить какому-то ip-адресу отправлять нам какой-либо трафик (так как не указали ни протокол, ни порт, то любые пакеты от этого ip будут удаляться):
sudo iptables -I INPUT -s 209.175.153.23 -j DROP # -I - _insert (вставить в начало списка, чтобы правило сработало первым)_, -s - _source_
```
Также таким образом можно, наоборот, разрешить какой-то трафик на этот ip, то есть комбинировать параметры.

Очень важен порядок расположения правил (есть вероятность отключить себя, если писать правила в неверном порядке):
* сначала должны быть правила DROP (сюда входят адреса, от которых мы блокируем трафик)
* далее правила ACCEPT (но здесь также важен порядок правил, чтобы какие-то пакеты выполнялись с большей приоритетностью, чтобы не расходывать ресурсы).
```

__Пока состояние firewall еще не сохранено на диске и существует только в оперативной памяти, соответственно, не будет применяться при перезагрузке.
Поэтому, если выкинуло из соединения, потому что не настроен ssh, в таком случае возможна перезагрузка сервера (например выключить рубильник) и при загрузке файервол будет пустым.__


### Сохранение правил
```
sudo iptables-save > ./iptables.rules # запишет установленные правила в конфигурационный файл
```
В этом файле можно изменить порядок правил и передать их обратно команде iptables -L -nv:
```
iptables-restore < ./iptables.rules # обратить внимание на обратную стрелку, данная команда зеркальная предыдущей 
```

#### Если необходимо, чтобы эти правила применялись при загрузке системы, устанавливаем пакеты:
```
sudo apt install iptables-persistent netfilter-persistent
```
предлагает сохранить используемые сейчас правила IPv4, а также IPv6 (их также необходимо настраивать с помощью ip6tables, если используются).

__Правила сохраняются здесь:__
/etc/iptables/rules.v4
/etc/iptables/rules.v6
тут также можно перетасовать правила в нужном порядке.

__Также можно сохранить эти команды:__
```
netfilter-persistent save
```
__Запустить эти команды:__
```
netfilter-persistent start
```

__Если есть Docker, то поверх iptables докинутся правила докера__

__узнать, какие порты используются:__
```
sudo ss -ntulp # это разновидность netstat, но показывает статусы портов socket stat - показывает, какие службы на каких портах слушаются
(если в колонке Local Address Port стоит 127.0.0.1:port, значит этот порт слушает только наш локальный компьютер, если стоит 0.0.0.0:port, значит этот порт слушает все порты, то есть любой может подключиться, имея доступ к нашему сетевому интерфейсу).
```
__Протоколы:__
TCP/IP – используется для передачи данных по интернету
HTTP – для доступа к веб-страницам
FTP – для передачи файлов
SMTP – для отправки электронной почты
DNS – для разрешения доменных имён в IP-адреса

__Стандартные порты__
1. 80 - http
2. 443 - https
3. 22 - ssh
4. 25 - smtp (почта)
5. 3306 - mysql

```
Когда пакет приходит на сервер, то сначала происходит сопоставление с правилами iptables, а только потом с политикой по умолчанию.
```







__Команды:__
команды запускаются с sudo
1. iptables -L -nv # флаги L - режим списка правил в таблице, n - вывод в цифрах, v - подробно
2. iptables -L -t nat # задать таблицу явно (в данном случае таблица nat)
3. iptables -L -v # вывод в более подробном виде
4. iptables –F # очистка всех правил (по умолчанию очистит таблицу filter, для очистки другой таблицы ее нужно явно задать iptables -F -t nat), чтобы очистить одну цепочку, также нужно указать ее
5. iptables -X INPUT # удалить цепочку 

Политика по умолчанию (policy ACCEPT - принимает все пакеты или policy DROP - удаляет пакеты или policy REJECT - предполагает, что наш компьютер отвечает на каждый пакет отказом отказом, таким образом это расходует ресурс, а также сервер обнаруживает себя в сети)

6. iptables -P INPUT DROP # изменение политики по умолчанию в цепочке INPUT на DROP (по умолчанию в таблицу filter)

если поставить политику по умолчанию DROP, то не только другие компьютеры не смогут отправлять нам пакеты, но и наш компьютер не сможет отправить пакеты, поэтому нужно ввести правило:

7. iptables -A INPUT conntrack --ctstate RELATED, ESTABLISHED -j ACCEPT # таким образом наш компьютер сможет отправить пакеты, а другие компьютеры к нам - не смогут (проверяем ping-ом)

или

iptables -A INPUT -m state --state ESTABLISHED, RELAITED -j ACCEPT # также отвечает за то, чтобы пакеты приходили обратно по запросу нашего компьютера

также при политике по умолчанию DROP обязательно нужно разрешить доступ для самого себя - lo (локального интерфейса - 127.0.0.1):

8. iptables -A INPUT -i lo -j ACCEPT
9. iptables -D INPUT -i lo -j ACCEPT # удаление правила
10. iptables -A INPUT -i enp0s8 -m tcp -p tcp --dport 80 -j ACCEPT # правило, разрешающее по протоколу tcp accept на порт 80 (с другой машины можно будет подключиться по этому порту)
11. iptables -A INPUT -i enp0s8 -m multiport -p tcp --dports 80:8080 -j ACCEPT # правило, разрешающее по протоколу tcp accept на порты с 80 по 8080
12. iptables -A INPUT -i enp0s8 -s 192.168.20.0/24 -m tcp -p tcp --dport 80 -j ACCEPT # дать доступ для определенной подсети и порта, то есть наши пакеты сможет получить только компьютеры из подсети 192.168.20.0/24 (весь диапазон адресов с 1 по 254) с порта 80

__nat__
  a. доступ из интернета к компьютерам локальной сети
  b. доступ из локальной сети в интернет с динамическим IP-адресом
  c. доступ из локальной сети в интернет со статическим IP-адресом

nat не будет работать, если не включен forwarding:
 * nano /etc/sysctl.conf (данные конфигурации будут применяться при каждой загрузке) >
 раскомментировать строку net.ipv4.tcp_syncookies=1 >
 перезагрузиться (либо без перезагрузки echo 1 > /proc/sys/net/ipv4/ip_forward # не сохраняется при перезагрузке)

__Доступ из локальной сети в интернет с динамическим IP-адресом:__
Для этого на компьютере, который имеет доступ в интернет пишем команду:

13. iptables -A POSTROUTING -t nat -s 192.168.20.0/24 -o enp0s3 -j MASQUERADE # подсеть компьютера без доступа в интернет, интерфейс, который смотрит в сторону интернета (после этого у компьютера можно проверить ping)

```
MASQUERADE применяется в работе с динамическим IP-адресом и использует дополнительные ресурсы компьютера для постоянного сопоставления IP-адресов.
Если на компьютере статический IP-адрес, то нужно использовать SNAT для экономии ресурсов компьютера.
```

__Доступ из локальной сети в интернет со статическим IP-адресом:__

14. iptables -A POSTROUTING -t nat -s 192.168.20.0/24 -o enp0s3 -j SNAT --to-source 192.168.1.223 # 192.168.1.223 - IP текущего сетевого интерфейса enp0s3 (на этом компьютере с доступом в интернет)

```
если не работает ping в браузере или к терминале, нужно отключить и снова включить сетевой интерфейс, смотрящий в интернет:

ifconfig enp0s3 down
ifconfig enp0s3 up

и точно так же для компьютера в локальной сети - выключить и включить
```
__Доступ из интернета к компьютерам локальной сети:__

15. iptables -A PREROUTING -t nat -i enp0s3 -p tcp --dport 900 -j DNAT --to-destination 192.168.20.2

__Все полученные правила нужно сохранить, чтобы они работали после перезагрузки__

16. iptables-save > /root/iptables-rules

__Восстановить удаленные правила во всех таблицах iptables:__

17. iptables-restore < /root/iptables-rules

__Чтобы все правила iptables устанавливались при загрузке системы:__

18. nano /etc/network/interfaces # файл для настройки сетевых интерфейсов (скорее всего netplan)
и в файле пишем:
```
pre-up iptables-restore < /root/iptables-rules
```

Создать файл /etc/firewall.sh, имитирующий фаерволл, на ws1 и ws2:
```
#!/bin/sh

# Удаление всех правил в таблице "filter" (по-умолчанию).
iptables –F
iptables -X
```

19. sudo ss -ntulp (или sudo ss -ntlp) # посмотреть, какие порты открыты

20. iptables -A INPUT -p icmp -j ACCEPT # icmp отвечает за ping, может использоваться в других утилитах

21. iptables -I INPUT -s 209.175.153.23 -j DROP # -I (insert), чтобы поставить правило в самое начало для того, чтобы стоящие впереди разрешающие правила не пропустили этот IP



Нужно добавить в файл подряд следующие правила:
1) на ws1 применить стратегию когда в начале пишется запрещающее правило, а в конце пишется разрешающее правило (это касается пунктов 4 и 5)
2) на ws2 применить стратегию когда в начале пишется разрешающее правило, а в конце пишется запрещающее правило (это касается пунктов 4 и 5)
3) открыть на машинах доступ для порта 22 (ssh) и порта 80 (http)

```
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
```

4) запретить echo reply (машина не должна "пинговаться”, т.е. должна быть блокировка на OUTPUT)

5) разрешить echo reply (машина должна "пинговаться")
В отчёт поместить скрины с содержанием файла /etc/firewall для каждой машины.
```
w1:
  4) iptables -A INPUT -p icmp -j DROP # не пингуется
  5) iptables -A INPUT -p icmp -j ACCEPT # не пингуется, так как правило стоит после запрещающего правила
w2:
  4) iptables -I INPUT -p icmp -j DROP # не пингуется
  5) iptables -I INPUT -p icmp -j ACCEPT # пингуется, так как правило стоит перез запрещающим правилом
```
Запустить файлы на обеих машинах командами chmod +x /etc/firewall.sh и /etc/firewall.sh
В отчёт поместить скрины с запуском обоих файлов.
В отчёте описать разницу между стратегиями, применёнными в первом и втором файлах.

Все делается либо через root, либо с sudo

ws1 - iptables

![](https://github.com/yulia-star/linux_project2/blob/main/ws1-ipt.png)
![](https://github.com/yulia-star/linux_project2/blob/main/ws1-iptables.png)

ws2 - iptables

![](https://github.com/yulia-star/linux_project2/blob/main/ws2-ipt.png)
![](https://github.com/yulia-star/linux_project2/blob/main/ws2-iptables.png)




### 4.2. Утилита nmap
Командой ping найти машину, которая не "пингуется", после чего утилитой nmap показать, что хост машины запущен
Проверка: в выводе nmap должно быть сказано: Host is up

В отчёт поместить скрины с вызовом и выводом использованных команд ping и nmap.
Сохранить дампы образов виртуальных машин
p.s. Ни в коем случае не сохранять дампы в гит!

nmap не был скачан пришлось сначала удалять команды из iptables (iptables -F), скачивать, а потом уже заново их устанавливать и тестировать nmap

![](https://github.com/yulia-star/linux_project2/blob/main/nmap.png)


## Part 5. Статическая маршрутизация сети

Сеть:
![part5_network](https://raw.githubusercontent.com/yulia-star/linux_project2/main/part5_network.png)

Поднять пять виртуальных машин (3 рабочие станции (ws11, ws21, ws22) и 2 роутера (r1, r2))
### 5.1. Настройка адресов машин
Настроить конфигурации машин в etc/netplan/00-installer-config.yaml согласно сети на рисунке.
В отчёт поместить скрины с содержанием файла etc/netplan/00-installer-config.yaml для каждой машины.
Перезапустить сервис сети. Если ошибок нет, то командой ip -4 a проверить, что адрес машины задан верно. Также пропинговать ws22 с ws21. Аналогично пропинговать r1 с ws11.

Для настройки связи между машинами в VirtualBox в настройках каждой машины в качествн адаптера устанавливала параметр Внутренняя сеть.

yaml-файлы

![](https://github.com/yulia-star/linux_project2/blob/main/all-yaml.png)

ping

![](https://github.com/yulia-star/linux_project2/blob/main/all-ping.png)



### 5.2. Включение переадресации IP-адресов.
Для включения переадресации IP, выполните команду на роутерах:
```sysctl -w net.ipv4.ip_forward=1``` При таком подходе переадресация не будет работать после перезагрузки системы.

В отчёт поместить скрин с вызовом и выводом использованной команды.
Откройте файл ```/etc/sysctl.conf``` и добавьте в него следующую строку:
```net.ipv4.ip_forward = 1``` При использовании этого подхода, IP-переадресация включена на постоянной основе.

В отчёт поместить скрин с содержанием изменённого файла /etc/sysctl.conf.

![](https://github.com/yulia-star/linux_project2/blob/main/forward_cmd.png)
![](https://github.com/yulia-star/linux_project2/blob/main/forward_file.png)

### 5.3. Установка маршрута по-умолчанию
Пример вывода команды ip r после добавления шлюза:

default via 10.10.0.1 dev eth0
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.2
Настроить маршрут по-умолчанию (шлюз) для рабочих станций. Для этого добавить gateway4 [ip роутера] в файле конфигураций
В отчёт поместить скрин с содержанием файла etc/netplan/00-installer-config.yaml.

![](https://github.com/yulia-star/linux_project2/blob/main/gateway.png)

Вызвать ip r и показать, что добавился маршрут в таблицу маршрутизации.
В отчёт поместить скрин с вызовом и выводом использованной команды.

![](https://github.com/yulia-star/linux_project2/blob/main/ip%20r.png)

Пропинговать с ws11 роутер r2 и показать на r2, что пинг доходит. Для этого использовать команду:
tcpdump -tn -i eth1

В отчёт поместить скрин с вызовом и выводом использованных команд.

![](https://github.com/yulia-star/linux_project2/blob/main/ping%20ws11%20-%20r2.png)


![part5_network](https://raw.githubusercontent.com/yulia-star/linux_project2/main/part5_network.png)

### 5.4. Добавление статических маршрутов
Добавить в роутеры r1 и r2 статические маршруты в файле конфигураций. Пример для r1 маршрута в сетку 10.20.0.0/26:
__Добавить в конец описания сетевого интерфейса eth1:__
- to: 10.20.0.0
  via: 10.100.0.12
В отчёт поместить скрины с содержанием изменённого файла etc/netplan/00-installer-config.yaml для каждого роутера.

![](https://github.com/yulia-star/linux_project2/blob/main/gateway-r.png)

Вызвать ip r и показать таблицы с маршрутами на обоих роутерах.

Пример таблицы на r1:
10.100.0.0/16 dev eth1 proto kernel scope link src 10.100.0.11
10.20.0.0/26 via 10.100.0.12 dev eth1
10.10.0.0/18 dev eth0 proto kernel scope link src 10.10.0.1
В отчёт поместить скрин с вызовом и выводом использованной команды.

![](https://github.com/yulia-star/linux_project2/blob/main/ip%20r%20-%20r.png)

Запустить команды на ws11:
ip r list 10.10.0.0/[маска сети] и ip r list 0.0.0.0/0

В отчёт поместить скрин с вызовом и выводом использованных команд.
В отчёте объяснить, почему для адреса 10.10.0.0/[порт сети] был выбран маршрут, отличный от 0.0.0.0/0, хотя он попадает под маршрут по-умолчанию.

![](https://github.com/yulia-star/linux_project2/blob/main/ws11%20-%20ip%20r%20list.png)

### 5.5. Построение списка маршрутизаторов
Пример вывода утилиты traceroute после добавления шлюза:

1 10.10.0.1 0 ms 1 ms 0 ms
2 10.100.0.12 1 ms 0 ms 1 ms
3 10.20.0.10 12 ms 1 ms 3 ms
Запустить на r1 команду дампа:
tcpdump -tnv -i eth0

При помощи утилиты traceroute построить список маршрутизаторов на пути от ws11 до ws21
В отчёт поместить скрины с вызовом и выводом использованных команд (tcpdump и traceroute).
В отчёте, опираясь на вывод, полученный из дампа на r1, объяснить принцип работы построения пути при помощи traceroute.
### 5.6. Использование протокола ICMP при маршрутизации
Запустить на r1 перехват сетевого трафика, проходящего через eth0 с помощью команды:
tcpdump -n -i eth0 icmp

Пропинговать с ws11 несуществующий IP (например, 10.30.0.111) с помощью команды:
ping -c 1 10.30.0.111

В отчёт поместить скрин с вызовом и выводом использованных команд.
Сохранить дампы образов виртуальных машин
p.s. Ни в коем случае не сохранять дампы в гит!

## Part 6. Динамическая настройка IP с помощью DHCP

В данном задании используются виртуальные машины из Части 5

Для r2 настроить в файле /etc/dhcp/dhcpd.conf конфигурацию службы DHCP:
1) указать адрес маршрутизатора по-умолчанию, DNS-сервер и адрес внутренней сети. Пример файла для r2:
subnet 10.100.0.0 netmask 255.255.0.0 {}

subnet 10.20.0.0 netmask 255.255.255.192
{
    range 10.20.0.2 10.20.0.50;
    option routers 10.20.0.1;
    option domain-name-servers 10.20.0.1;
}
2) в файле resolv.conf прописать nameserver 8.8.8.8.
В отчёт поместить скрины с содержанием изменённых файлов.
Перезагрузить службу DHCP командой systemctl restart isc-dhcp-server. Машину ws21 перезагрузить при помощи reboot и через ip a показать, что она получила адрес. Также пропинговать ws22 с ws21.
В отчёт поместить скрины с вызовом и выводом использованных команд.
Указать MAC адрес у ws11, для этого в etc/netplan/00-installer-config.yaml надо добавить строки: macaddress: 10:10:10:10:10:BA, dhcp4: true
В отчёт поместить скрин с содержанием изменённого файла etc/netplan/00-installer-config.yaml.
Для r1 настроить аналогично r2, но сделать выдачу адресов с жесткой привязкой к MAC-адресу (ws11). Провести аналогичные тесты
В отчёте этот пункт описать аналогично настройке для r2.
Запросить с ws21 обновление ip адреса
В отчёте поместить скрины ip до и после обновления.
В отчёте описать, какими опциями DHCP сервера пользовались в данном пункте.
Сохранить дампы образов виртуальных машин
p.s. Ни в коем случае не сохранять дампы в гит!

## Part 7. NAT

В данном задании используются виртуальные машины из Части 5

В файле /etc/apache2/ports.conf на ws22 и r2 изменить строку Listen 80 на Listen 0.0.0.0:80, то есть сделать сервер Apache2 общедоступным
В отчёт поместить скрин с содержанием изменённого файла.
Запустить веб-сервер Apache командой service apache2 start на ws22 и r1
В отчёт поместить скрины с вызовом и выводом использованной команды.
Добавить в фаервол, созданный по аналогии с фаерволом из Части 4, на r2 следующие правила:
1) Удаление правил в таблице filter - iptables -F
2) Удаление правил в таблице "NAT" - iptables -F -t nat
3) Отбрасывать все маршрутизируемые пакеты - iptables --policy FORWARD DROP
Запускать файл также, как в Части 4
Проверить соединение между ws22 и r1 командой ping
При запуске файла с этими правилами, ws22 не должна "пинговаться" с r1

В отчёт поместить скрины с вызовом и выводом использованной команды.
Добавить в файл ещё одно правило:
4) Разрешить маршрутизацию всех пакетов протокола ICMP
Запускать файл также, как в Части 4
Проверить соединение между ws22 и r1 командой ping
При запуске файла с этими правилами, ws22 должна "пинговаться" с r1

В отчёт поместить скрины с вызовом и выводом использованной команды.
Добавить в файл ещё два правила:
5) Включить SNAT, а именно маскирование всех локальных ip из локальной сети, находящейся за r2 (по обозначениям из Части 5 - сеть 10.20.0.0)
Совет: стоит подумать о маршрутизации внутренних пакетов, а также внешних пакетов с установленным соединением

6) Включить DNAT на 8080 порт машины r2 и добавить к веб-серверу Apache, запущенному на ws22, доступ извне сети
Совет: стоит учесть, что при попытке подключения возникнет новое tcp-соединение, предназначенное ws22 и 80 порту

В отчёт поместить скрин с содержанием изменённого файла.
Запускать файл также, как в Части 4
Перед тестированием рекомендуется отключить сетевой интерфейс NAT (его наличие можно проверить командой ip a) в VirtualBox, если он включен

Проверить соединение по TCP для SNAT, для этого с ws22 подключиться к серверу Apache на r1 командой:
telnet [адрес] [порт]

Проверить соединение по TCP для DNAT, для этого с r1 подключиться к серверу Apache на ws22 командой telnet (обращаться по адресу r2 и порту 8080)
В отчёт поместить скрины с вызовом и выводом использованных команд.
Сохранить дампы образов виртуальных машин
p.s. Ни в коем случае не сохранять дампы в гит!

## Part 8. Дополнительно. Знакомство с SSH Tunnels
- Пожалуй, на этом у меня всё. Может у тебя появились ещё какие-то вопросы?

- Да, я хотел спросить ещё об одной вещи. На работе я краем уха услышал, что в моей компании есть некие проекты по обучению. Подробностей я не знаю, но очень хочется взглянуть... Вдруг будет полезно

- Действительно интересно, но как в этом помогу тебе я?

- Дело в том, что, чтобы добраться до этих проектов, нужно получить доступ к закрытой сети. Можешь посоветовать что-нибудь по этому поводу?

- Ну ты, конечно, даёшь... Не уверен на все сто, что это поможет, но могу рассказать тебе про SSH Tunnels.

== Задание ==

В данном задании используются виртуальные машины из Части 5

Запустить веб-сервер Apache на ws22 только на localhost (то есть не изменять файл /etc/apache2/ports.conf или, если был изменен ранее, вернуть строку Listen 80)
Воспользоваться Local TCP forwarding с ws21 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws21
Воспользоваться Remote TCP forwarding c ws11 до ws22, чтобы получить доступ к веб-серверу на ws22 с ws11
Для проверки, сработало ли подключение в обоих предыдущих пунктах, перейдите во второй терминал (например, клавишами Alt + F2) и выполните команду:
telnet 127.0.0.1 [локальный порт]

В отчёте описать команды, необходимые для выполнения этих четырёх пунктов, а также приложить скриншоты с их вызовом и выводом.
Сохранить дампы образов виртуальных машин
p.s. Ни в коем случае не сохранять дампы в гит!
